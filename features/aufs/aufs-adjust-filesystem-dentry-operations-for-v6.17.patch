From a515ba246e262cb64f7486d97c5b25fe343c511b Mon Sep 17 00:00:00 2001
From: Bruce Ashfield <bruce.ashfield@gmail.com>
Date: Fri, 19 Sep 2025 09:53:35 -0400
Subject: [PATCH] aufs: adjust filesystem / dentry operations for v6.17

first change:

  s_d_op was removed and replaced by a helper set_default_d_op() (the
  kernel now keeps the default dentry ops in an internal member and
  exposes a setter). The fix for aufs is:

    - stop reading/writing sb->s_d_op directly,
    - call set_default_d_op(sb, ops) to set the default dentry ops,
    - avoid relying on sb->s_d_op to read back the current default

second change:

  aufs assigns rd.old_dir = src_dir and rd.new_dir = dir but struct
  renamedata no longer has old_dir/new_dir (these were changed to parent
  dentrys: old_parent/new_parent).

third change:

  call_mmap() is part of the mm/vfs refactor (there was movement to
  rename the helper to vfs_mmap() and to add mmap_prepare()
  compatibility).

Signed-off-by: Bruce Ashfield <bruce.ashfield@gmail.com>
---
 fs/aufs/dentry.c | 11 +++++++----
 fs/aufs/f_op.c   |  3 ++-
 fs/aufs/fsctx.c  | 10 +++++++---
 fs/aufs/super.c  | 19 ++++++++++++++-----
 fs/aufs/vfsub.c  | 15 +++++++++++----
 5 files changed, 41 insertions(+), 17 deletions(-)

diff --git a/fs/aufs/dentry.c b/fs/aufs/dentry.c
index ff43181f0d35..88530c903695 100644
--- a/fs/aufs/dentry.c
+++ b/fs/aufs/dentry.c
@@ -730,17 +730,20 @@ static int au_refresh_by_dinfo(struct dentry *dentry, struct au_dinfo *dinfo,
 
 void au_refresh_dop(struct dentry *dentry, int force_reval)
 {
-	const struct dentry_operations *dop
-		= force_reval ? &aufs_dop : dentry->d_sb->s_d_op;
-	static const unsigned int mask
-		= DCACHE_OP_REVALIDATE | DCACHE_OP_WEAK_REVALIDATE;
+	const struct dentry_operations *dop;
+	static const unsigned int mask =
+		DCACHE_OP_REVALIDATE | DCACHE_OP_WEAK_REVALIDATE;
 
 	BUILD_BUG_ON(sizeof(mask) != sizeof(dentry->d_flags));
 
+	/* decide dop explicitly, since sb->s_d_op is gone */
+	dop = force_reval ? &aufs_dop : &aufs_dop_noreval;
+
 	if (dentry->d_op == dop)
 		return;
 
 	AuDbg("%pd\n", dentry);
+
 	spin_lock(&dentry->d_lock);
 	if (dop == &aufs_dop)
 		dentry->d_flags |= mask;
diff --git a/fs/aufs/f_op.c b/fs/aufs/f_op.c
index de795fbfaf4e..e1f86e76502a 100644
--- a/fs/aufs/f_op.c
+++ b/fs/aufs/f_op.c
@@ -645,7 +645,8 @@ static int aufs_mmap(struct file *file, struct vm_area_struct *vma)
 	 *			 au_flag_conv(vma->vm_flags));
 	 */
 	if (!err)
-		err = call_mmap(h_file, vma);
+		/* modern helper name (vfs wrapper for mmap/mmap_prepare) */
+		err = vfs_mmap(h_file, vma);
 	if (!err) {
 		au_vm_prfile_set(vma, file);
 		fsstack_copy_attr_atime(inode, file_inode(h_file));
diff --git a/fs/aufs/fsctx.c b/fs/aufs/fsctx.c
index 01d224a5273b..52dd45471236 100644
--- a/fs/aufs/fsctx.c
+++ b/fs/aufs/fsctx.c
@@ -110,6 +110,7 @@ static int au_fsctx_fill_super(struct super_block *sb, struct fs_context *fc)
 	struct au_sbinfo *sbinfo = a->sbinfo;
 	struct dentry *root;
 	struct inode *inode;
+	const struct dentry_operations *dops = &aufs_dop;
 
 	sbinfo->si_sb = sb;
 	sb->s_fs_info = sbinfo;
@@ -122,7 +123,8 @@ static int au_fsctx_fill_super(struct super_block *sb, struct fs_context *fc)
 	/* all timestamps always follow the ones on the branch */
 	sb->s_flags |= SB_NOATIME | SB_NODIRATIME | SB_I_VERSION;
 	sb->s_op = &aufs_sop;
-	sb->s_d_op = &aufs_dop;
+	dops = &aufs_dop;
+	set_default_d_op(sb, dops);
 	sb->s_magic = AUFS_SUPER_MAGIC;
 	sb->s_maxbytes = 0;
 	sb->s_stack_depth = 1;
@@ -145,9 +147,11 @@ static int au_fsctx_fill_super(struct super_block *sb, struct fs_context *fc)
 	err = au_opts_mount(sb, &a->opts);
 	AuTraceErr(err);
 	if (!err && au_ftest_si(sbinfo, NO_DREVAL)) {
-		sb->s_d_op = &aufs_dop_noreval;
+                dops = &aufs_dop_noreval;
+                set_default_d_op(sb, dops);
 		/* infofc(fc, "%ps", sb->s_d_op); */
-		pr_info("%ps\n", sb->s_d_op);
+                /* print the dentry ops pointer we just set (no public getter). */
+                pr_info("%ps\n", dops);		
 		au_refresh_dop(root, /*force_reval*/0);
 		sbinfo->si_iop_array = aufs_iop_nogetattr;
 		au_refresh_iop(inode, /*force_getattr*/0);
diff --git a/fs/aufs/super.c b/fs/aufs/super.c
index 7290cc0d1b59..edb8b3d3d540 100644
--- a/fs/aufs/super.c
+++ b/fs/aufs/super.c
@@ -25,6 +25,7 @@
 #include <linux/seq_file.h>
 #include <linux/statfs.h>
 #include <linux/vmalloc.h>
+#include <linux/dcache.h> /* for set_default_d_op() */
 #include "aufs.h"
 
 /*
@@ -734,18 +735,26 @@ void au_remount_refresh(struct super_block *sb, unsigned int do_idop)
 
 	if (do_idop) {
 		if (au_ftest_si(sbi, NO_DREVAL)) {
-			AuDebugOn(sb->s_d_op == &aufs_dop_noreval);
-			sb->s_d_op = &aufs_dop_noreval;
+                        /* set default dentry ops for this superblock */
+                        set_default_d_op(sb, &aufs_dop_noreval);
 			AuDebugOn(sbi->si_iop_array == aufs_iop_nogetattr);
 			sbi->si_iop_array = aufs_iop_nogetattr;
 		} else {
-			AuDebugOn(sb->s_d_op == &aufs_dop);
-			sb->s_d_op = &aufs_dop;
+                        /* restore default dentry ops */
+                        set_default_d_op(sb, &aufs_dop);
 			AuDebugOn(sbi->si_iop_array == aufs_iop);
 			sbi->si_iop_array = aufs_iop;
 		}
 		pr_info("reset to %ps and %ps\n",
-			sb->s_d_op, sbi->si_iop_array);
+                        /* previous code passed sb->s_d_op here; sb->s_d_op
+						 * is no longer exported.  The callers below expect
+						 * the specific dentry ops pointer â€” pass the
+						 * appropriate one explicitly (aufs uses aufs_dop
+						 * or aufs_dop_noreval).  If the intent was the
+						 * current default, pass the same pointer you set
+						 * above or NULL if no-op is acceptable.
+						 */
+                        &aufs_dop, sbi->si_iop_array);
 	}
 
 	di_write_unlock(root);
diff --git a/fs/aufs/vfsub.c b/fs/aufs/vfsub.c
index 483548be86b4..24dd1d96ef22 100644
--- a/fs/aufs/vfsub.c
+++ b/fs/aufs/vfsub.c
@@ -484,11 +484,18 @@ int vfsub_rename(struct inode *src_dir, struct dentry *src_dentry,
 		goto out;
 
 	rd.old_mnt_idmap = mnt_idmap(path->mnt);
-	rd.old_dir = src_dir;
-	rd.old_dentry = src_dentry;
+
+	/* convert old/new dir (inode) style -> parent dentry style */
+	rd.old_parent = dget_parent(src_dentry);   /* parent dentry of source */
+	rd.old_dentry = src_dentry;                 /* the dentry being renamed */
+	rd.new_parent = dget_parent(path->dentry);        /* parent dentry of target */
+	rd.new_dentry = path->dentry;                     /* the target dentry */
+	
+	/* rd.old_dir = src_dir; */
+	/* rd.old_dentry = src_dentry; */
 	rd.new_mnt_idmap = rd.old_mnt_idmap;
-	rd.new_dir = dir;
-	rd.new_dentry = path->dentry;
+	/* rd.new_dir = dir; */
+	/* rd.new_dentry = path->dentry; */
 	rd.delegated_inode = delegated_inode;
 	rd.flags = flags;
 	lockdep_off();
-- 
2.39.2


From d9b2e42268e44e1cb3011bbb39e9e72d6ac36a67 Mon Sep 17 00:00:00 2001
From: Bruce Ashfield <bruce.ashfield@gmail.com>
Date: Tue, 9 Dec 2025 11:18:40 -0500
Subject: [PATCH] aufs6: mmap patch

Signed-off-by: Bruce Ashfield <bruce.ashfield@gmail.com>
---
 fs/Makefile          |  3 +++
 fs/au_mf.c           | 60 ++++++++++++++++++++++++++++++++++++++++++++
 fs/proc/base.c       |  2 +-
 fs/proc/nommu.c      |  2 +-
 fs/proc/task_nommu.c |  2 +-
 include/linux/fs.h   | 25 ++++++++++++++++++
 6 files changed, 91 insertions(+), 3 deletions(-)
 create mode 100644 fs/au_mf.c

diff --git a/fs/Makefile b/fs/Makefile
index 33ca8b1068623..d6a42848775e8 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -17,6 +17,9 @@ obj-y :=	open.o read_write.o file_table.o super.o \
 		fs_types.o fs_context.o fs_parser.o fsopen.o init.o \
 		kernel_read_file.o mnt_idmapping.o remap_range.o pidfs.o \
 		file_attr.o
+ifeq (${CONFIG_AUFS_FS},m)
+obj-y += au_mf.o
+endif
 
 obj-$(CONFIG_BUFFER_HEAD)	+= buffer.o mpage.o
 obj-$(CONFIG_PROC_FS)		+= proc_namespace.o
diff --git a/fs/au_mf.c b/fs/au_mf.c
new file mode 100644
index 0000000000000..bacf13696a772
--- /dev/null
+++ b/fs/au_mf.c
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2025 Junjiro R. Okajima
+ */
+
+#include <linux/fs.h>
+#include <linux/module.h>
+
+#if IS_MODULE(CONFIG_AUFS_FS)
+/*
+ * This au_mf.c (aufs mmapped files) is for external AUFS module only,
+ * and statically linked to kernel.
+ * See also $srctree/fs/Makefile.
+ * This linking may seem to be tricky. It is due to support the case when AUFS
+ * is configured as an external module, eg. VFS calls a function defined in the
+ * dynamic module.
+ */
+#else
+BUILD_BUG_ON_MSG(1, "CONFIG_AUFS_FS is disabled.");
+#endif
+
+const struct path *au_file_user_path(const struct file *f)
+{
+	const struct path *path,
+		*(*func)(const struct file *f),
+		*au_do_file_user_path(const struct file *f);
+
+	path = NULL;
+	func = symbol_get(au_do_file_user_path);
+	if (unlikely(!func))
+		/* "aufs" module is not loaded */
+		goto out;
+
+	path = func(f);
+	symbol_put(au_do_file_user_path);
+
+out:
+	return path;
+}
+EXPORT_SYMBOL_GPL(au_file_user_path);
+
+const struct inode *au_file_user_inode(const struct file *f)
+{
+	const struct inode *inode,
+		*(*func)(const struct file *f),
+		*au_do_file_user_inode(const struct file *f);
+
+	inode = NULL;
+	func = symbol_get(au_do_file_user_inode);
+	if (unlikely(!func))
+		/* "aufs" module is not loaded */
+		goto out;
+
+	inode = func(f);
+	symbol_put(au_do_file_user_inode);
+
+out:
+	return inode;
+}
+EXPORT_SYMBOL_GPL(au_file_user_inode);
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 6299878e3d97e..2905284f1dfa8 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -1788,7 +1788,7 @@ static int proc_exe_link(struct dentry *dentry, struct path *exe_path)
 	exe_file = get_task_exe_file(task);
 	put_task_struct(task);
 	if (exe_file) {
-		*exe_path = exe_file->f_path;
+		*exe_path = *file_user_path(exe_file);
 		path_get(&exe_file->f_path);
 		fput(exe_file);
 		return 0;
diff --git a/fs/proc/nommu.c b/fs/proc/nommu.c
index c6e7ebc637562..12c340dcdec3d 100644
--- a/fs/proc/nommu.c
+++ b/fs/proc/nommu.c
@@ -39,7 +39,7 @@ static int nommu_region_show(struct seq_file *m, struct vm_region *region)
 	file = region->vm_file;
 
 	if (file) {
-		struct inode *inode = file_inode(region->vm_file);
+		struct inode *inode = file_user_inode(region->vm_file);
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 	}
diff --git a/fs/proc/task_nommu.c b/fs/proc/task_nommu.c
index d362919f4f688..79a2590d40f4d 100644
--- a/fs/proc/task_nommu.c
+++ b/fs/proc/task_nommu.c
@@ -137,7 +137,7 @@ static int nommu_vma_show(struct seq_file *m, struct vm_area_struct *vma)
 	file = vma->vm_file;
 
 	if (file) {
-		struct inode *inode = file_inode(vma->vm_file);
+		struct inode *inode = file_user_inode(vma->vm_file);
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 		pgoff = (loff_t)vma->vm_pgoff << PAGE_SHIFT;
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0549e96b8db82..3428592320353 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2889,6 +2889,21 @@ struct file *dentry_create(const struct path *path, int flags, umode_t mode,
 			   const struct cred *cred);
 const struct path *backing_file_user_path(const struct file *f);
 
+#if IS_MODULE(CONFIG_AUFS_FS)
+/* fs/au_mf.c */
+const struct path *au_file_user_path(const struct file *f);
+const struct inode *au_file_user_inode(const struct file *f);
+#elif IS_BUILTIN(CONFIG_AUFS_FS)
+/* fs/aufs/mf.c */
+const struct path *au_do_file_user_path(const struct file *f);
+const struct inode *au_do_file_user_inode(const struct file *f);
+#define au_file_user_path(f)	au_do_file_user_path(f)
+#define au_file_user_inode(f)	au_do_file_user_inode(f)
+#else
+#define au_file_user_path(f)	NULL
+#define au_file_user_inode(f)	NULL
+#endif
+
 /*
  * When mmapping a file on a stackable filesystem (e.g., overlayfs), the file
  * stored in ->vm_file is a backing file whose f_inode is on the underlying
@@ -2901,15 +2916,25 @@ const struct path *backing_file_user_path(const struct file *f);
 /* Get the path to display in /proc/<pid>/maps */
 static inline const struct path *file_user_path(const struct file *f)
 {
+	const struct path *path;
+
 	if (unlikely(f->f_mode & FMODE_BACKING))
 		return backing_file_user_path(f);
+	path = au_file_user_path(f);
+	if (path)
+		return path;
 	return &f->f_path;
 }
 /* Get the inode whose inode number to display in /proc/<pid>/maps */
 static inline const struct inode *file_user_inode(const struct file *f)
 {
+	const struct inode *inode;
+
 	if (unlikely(f->f_mode & FMODE_BACKING))
 		return d_inode(backing_file_user_path(f)->dentry);
+	inode = au_file_user_inode(f);
+	if (inode)
+		return inode;
 	return file_inode(f);
 }
 
-- 
2.39.2


From 11bd714d2fa9480217bc3300d06b0b1e65ca8976 Mon Sep 17 00:00:00 2001
From: Bruce Ashfield <bruce.ashfield@gmail.com>
Date: Wed, 15 Oct 2025 20:04:40 -0400
Subject: [PATCH 2/2] aufs: fix errors (not all warnings) for v6.18-rc1

Signed-off-by: Bruce Ashfield <bruce.ashfield@gmail.com>
---
 fs/aufs/branch.h |  2 +-
 fs/aufs/super.c  |  8 +++++-
 fs/aufs/vfsub.c  | 68 +++++++++++-------------------------------------
 fs/aufs/vfsub.h  |  2 +-
 fs/aufs/xino.c   | 11 ++++----
 5 files changed, 29 insertions(+), 62 deletions(-)

diff --git a/fs/aufs/branch.h b/fs/aufs/branch.h
index 3f2c51613880..3d1633e158f2 100644
--- a/fs/aufs/branch.h
+++ b/fs/aufs/branch.h
@@ -261,7 +261,7 @@ void au_xino_clr(struct super_block *sb);
 int au_xino_set(struct super_block *sb, struct au_opt_xino *xiopt, int remount);
 struct file *au_xino_def(struct super_block *sb);
 int au_xino_init_br(struct super_block *sb, struct au_branch *br, ino_t hino,
-		    struct path *base);
+		    const struct path *base);
 
 ino_t au_xino_new_ino(struct super_block *sb);
 void au_xino_delete_inode(struct inode *inode, const int unlinked);
diff --git a/fs/aufs/super.c b/fs/aufs/super.c
index edb8b3d3d540..ef56f54df7ef 100644
--- a/fs/aufs/super.c
+++ b/fs/aufs/super.c
@@ -26,6 +26,7 @@
 #include <linux/statfs.h>
 #include <linux/vmalloc.h>
 #include <linux/dcache.h> /* for set_default_d_op() */
+#include <linux/fs.h>
 #include "aufs.h"
 
 /*
@@ -771,12 +772,17 @@ void au_remount_refresh(struct super_block *sb, unsigned int do_idop)
 		AuIOErr("refresh failed, ignored, %d\n", err);
 }
 
+static int aufs_drop_inode(struct inode *inode)
+{
+    return inode_generic_drop(inode);
+}
+
 const struct super_operations aufs_sop = {
 	.alloc_inode	= aufs_alloc_inode,
 	.destroy_inode	= aufs_destroy_inode,
 	.free_inode	= aufs_free_inode,
 	/* always deleting, no clearing */
-	.drop_inode	= generic_delete_inode,
+	.drop_inode	= aufs_drop_inode,
 	.show_options	= aufs_show_options,
 	.statfs		= aufs_statfs,
 	.put_super	= aufs_put_super,
diff --git a/fs/aufs/vfsub.c b/fs/aufs/vfsub.c
index 24dd1d96ef22..501d7b16682d 100644
--- a/fs/aufs/vfsub.c
+++ b/fs/aufs/vfsub.c
@@ -24,6 +24,7 @@
 #include <linux/nsproxy.h>
 #include <linux/security.h>
 #include <linux/splice.h>
+#include <linux/mnt_idmapping.h>
 #include "aufs.h"
 
 #ifdef CONFIG_AUFS_BR_FUSE
@@ -98,7 +99,7 @@ void vfsub_set_nlink(struct inode *inode, unsigned int nlink)
 	au_nlink_unlock(inode);
 }
 
-int vfsub_update_h_iattr(struct path *h_path, int *did)
+int vfsub_update_h_iattr(const struct path *h_path, int *did)
 {
 	int err;
 	struct kstat st;
@@ -171,9 +172,8 @@ int vfsub_atomic_open(struct inode *dir, struct dentry *dentry,
 		goto out;
 
 	au_lcnt_inc(&br->br_nfiles);
-	file->f_path.dentry = DENTRY_NOT_SET;
-	file->f_path.mnt = au_br_mnt(br);
-	AuDbg("%ps\n", dir->i_op->atomic_open);
+	        file->__f_path.dentry = DENTRY_NOT_SET;
+	        file->__f_path.mnt = au_br_mnt(br);	AuDbg("%ps\n", dir->i_op->atomic_open);
 	err = dir->i_op->atomic_open(dir, dentry, file, args->open_flag,
 				     args->create_mode);
 	if (unlikely(err < 0)) {
@@ -461,61 +461,23 @@ int vfsub_link(struct dentry *src_dentry, struct inode *dir, struct path *path,
 	return err;
 }
 
-int vfsub_rename(struct inode *src_dir, struct dentry *src_dentry,
-		 struct inode *dir, struct path *path,
+int vfsub_rename(struct inode *src_hdir, struct dentry *src_dentry,
+		 struct inode *hdir, struct path *path,
 		 struct inode **delegated_inode, unsigned int flags)
 {
-	int err;
 	struct renamedata rd;
-	struct path tmp = {
-		.mnt	= path->mnt
-	};
-	struct dentry *d;
-
-	IMustLock(dir);
-	IMustLock(src_dir);
-
-	d = path->dentry;
-	path->dentry = d->d_parent;
-	tmp.dentry = src_dentry->d_parent;
-	err = security_path_rename(&tmp, src_dentry, path, d, /*flags*/0);
-	path->dentry = d;
-	if (unlikely(err))
-		goto out;
+	int err;
+	struct mnt_idmap *idmap_local = au_br_idmap(au_sbr(src_dentry->d_sb, au_dbtop(src_dentry)));
 
-	rd.old_mnt_idmap = mnt_idmap(path->mnt);
-
-	/* convert old/new dir (inode) style -> parent dentry style */
-	rd.old_parent = dget_parent(src_dentry);   /* parent dentry of source */
-	rd.old_dentry = src_dentry;                 /* the dentry being renamed */
-	rd.new_parent = dget_parent(path->dentry);        /* parent dentry of target */
-	rd.new_dentry = path->dentry;                     /* the target dentry */
-	
-	/* rd.old_dir = src_dir; */
-	/* rd.old_dentry = src_dentry; */
-	rd.new_mnt_idmap = rd.old_mnt_idmap;
-	/* rd.new_dir = dir; */
-	/* rd.new_dentry = path->dentry; */
+	rd.mnt_idmap = idmap_local;
+	rd.old_parent = src_dentry->d_parent;
+	rd.old_dentry = src_dentry;
+	rd.new_parent = path->dentry->d_parent;
+	rd.new_dentry = path->dentry;
 	rd.delegated_inode = delegated_inode;
 	rd.flags = flags;
-	lockdep_off();
-	err = vfs_rename(&rd);
-	lockdep_on();
-	if (!err) {
-		int did;
-
-		tmp.dentry = d->d_parent;
-		vfsub_update_h_iattr(&tmp, &did);
-		if (did) {
-			tmp.dentry = src_dentry;
-			vfsub_update_h_iattr(&tmp, /*did*/NULL);
-			tmp.dentry = src_dentry->d_parent;
-			vfsub_update_h_iattr(&tmp, /*did*/NULL);
-		}
-		/*ignore*/
-	}
 
-out:
+	err = vfs_rename(&rd);
 	return err;
 }
 
@@ -721,7 +683,7 @@ int vfsub_fsync(struct file *file, struct path *path, int datasync)
 	if (!err) {
 		if (!path) {
 			AuDebugOn(!file);
-			path = &file->f_path;
+			path = (struct path *)&file->f_path;
 		}
 		vfsub_update_h_iattr(path, /*did*/NULL); /*ignore*/
 	}
diff --git a/fs/aufs/vfsub.h b/fs/aufs/vfsub.h
index 5f2a363b2dcd..2e7fc3614324 100644
--- a/fs/aufs/vfsub.h
+++ b/fs/aufs/vfsub.h
@@ -126,7 +126,7 @@ int vfsub_sync_filesystem(struct super_block *h_sb);
 
 /* ---------------------------------------------------------------------- */
 
-int vfsub_update_h_iattr(struct path *h_path, int *did);
+int vfsub_update_h_iattr(const struct path *h_path, int *did);
 struct file *vfsub_dentry_open(struct path *path, int flags);
 struct file *vfsub_filp_open(const char *path, int oflags, int mode);
 struct au_branch;
diff --git a/fs/aufs/xino.c b/fs/aufs/xino.c
index e6ffdfdb1d9c..f95f32496ad2 100644
--- a/fs/aufs/xino.c
+++ b/fs/aufs/xino.c
@@ -198,7 +198,7 @@ struct file *au_xino_create(struct super_block *sb, char *fpath, int silent,
 	inode = file_inode(file);
 	/* no delegation since it is just created */
 	if (vfsub_inode_nlink(inode, AU_I_BRANCH))
-		err = vfsub_unlink(h_dir, &file->f_path, /*delegated*/NULL,
+		err = vfsub_unlink(h_dir, &file->__f_path, /*delegated*/NULL,
 				   /*force*/0);
 	inode_unlock(h_dir);
 	dput(h_parent);
@@ -237,7 +237,7 @@ struct file *au_xino_create2(struct super_block *sb, struct path *base,
 	struct file *file;
 	struct dentry *dentry;
 	struct inode *dir, *delegated;
-	struct qstr *name;
+	const struct qstr *name;
 	struct path ppath, path;
 	int err, do_unlock;
 	struct au_xino_lock_dir ldir;
@@ -276,8 +276,7 @@ struct file *au_xino_create2(struct super_block *sb, struct path *base,
 	}
 
 	delegated = NULL;
-	err = vfsub_unlink(dir, &file->f_path, &delegated, /*force*/0);
-	au_xino_unlock_dir(&ldir);
+			err = vfsub_unlink(dir, (struct path *)&file->f_path, &delegated, /*force*/0);	au_xino_unlock_dir(&ldir);
 	do_unlock = 0;
 	if (unlikely(err == -EWOULDBLOCK)) {
 		pr_warn("cannot retry for NFSv4 delegation"
@@ -1669,7 +1668,7 @@ struct file *au_xino_def(struct super_block *sb)
  * if found then share the xinofile with another branch.
  */
 int au_xino_init_br(struct super_block *sb, struct au_branch *br, ino_t h_ino,
-		    struct path *base)
+		    const struct path *h_path)
 {
 	int err;
 	struct au_xino_do_set_br args = {
@@ -1679,7 +1678,7 @@ int au_xino_init_br(struct super_block *sb, struct au_branch *br, ino_t h_ino,
 
 	args.bshared = sbr_find_shared(sb, /*btop*/0, au_sbbot(sb),
 				       au_br_sb(br));
-	err = au_xino_do_set_br(sb, base, &args);
+	err = au_xino_do_set_br(sb, h_path, &args);
 	if (unlikely(err))
 		au_xino_put(br);
 
-- 
2.39.2

